#!/usr/bin/env bash

# --- BEGIN jqmd runtime ---

jqmd_imports=
jqmd_filters=
jqmd_defines=

HAVE_FILTERS() { [[ ${jqmd_filters-} ]]; }
CLEAR_FILTERS() { unset jqmd_filters; }

IMPORTS() { jqmd_imports+="${jqmd_imports:+$'\n'}$1"; }
DEFINE()  { jqmd_defines+="${jqmd_defines:+$'\n'}$1"; }
FILTER()  { jqmd_filters+="${jqmd_filters:+|}$1"; }

JQOPTS=(jq)
JQ_OPTS() { JQOPTS+=("$@"); }
ARG()     { JQ_OPTS --arg     "$1" "$2"; }
ARGJSON() { JQ_OPTS --argjson "$1" "$2"; }

RUN_JQ() {
    local opt nargs cmd=(jq); set -- "${JQOPTS[@]:1}" "$@"

    while (($#)); do
        case "$1" in
        -{f,-fromfile})                     nargs=2 ; FILTER "$(<"$2")" ;;
        -{L,-indent})                       nargs=2 ;;
        --{arg,arjgson,slurpfile,argfile})  nargs=3 ;;
        --)  break   ;; # rest of args are data files
        -*)  nargs=1 ;;
        *)   FILTER "$1"; break ;; # jq program: data files follow
        esac
        cmd+=("${@:1:$nargs}")    # add $nargs args to cmd
        shift $nargs
    done

    HAVE_FILTERS || FILTER .    # jq needs at least one filter expression

    "${cmd[@]}" -f <(
        printf "%s\n" "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"
    ) "${@:2}"

    CLEAR_FILTERS   # cleanup for any re-runs
}

YAML()    { JSON "$(echo "$1" | yaml2json /dev/stdin)"; }
JSON()    { FILTER "jqmd_data($1)"; }

command -v yaml2json >/dev/null || yaml2json() {
    python -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)';
}

# --- END jqmd runtime ---

# Run as developer user
[[ $(whoami) == 'developer' ]] || exec as-developer "$0" "$@";

# Exit on error
set -euo pipefail

if ! REPLY=$(wp db tables); then
    wp db create
fi

if ! wp core is-installed; then
    wp core install --skip-email \
        --url="$WP_HOME" \
        --title="Placeholder" \
        --admin_user="$WP_ADMIN_USER" \
        --admin_email="$WP_ADMIN_EMAIL" \
        ${WP_ADMIN_PASS:+--admin_password="$WP_ADMIN_PASS"}
fi
DEFINE  $'def jqmd_data($data): . as $orig |\n    reduce paths(type=="array") as $path (\n        (. // {}) * $data; setpath( $path; ($orig | getpath($path)) + ($data | getpath($path)) )\n    );\n'
JSON \{\"options\":\{\}\}
mdsh_raw_php+=($'$state = json_decode($args[0], true);\n$options = empty($state[\'options\']) ? [] : $state[\'options\'];\n\nforeach ($options as $opt => $new) {\n    $old = get_option($opt);\n    if (is_array($old) && is_array($new)) $new = array_replace_recursive($old, $new);\n    if ($new !== $old) {\n        if ($old === false) add_option($opt, $new); else update_option($opt, $new);\n    }\n}\n')
for REPLY in ${MANTLE_STATES-}; do source ./states/$REPLY.state; done

REPLY=$(RUN_JQ -c -n)
printf '%s\n' '<?php' "${mdsh_raw_php[@]}" | wp eval-file - "$REPLY"

CLEAR_FILTERS  # prevent auto-run to stdout
if [[ $0 == $BASH_SOURCE ]] && HAVE_FILTERS; then RUN_JQ; fi
